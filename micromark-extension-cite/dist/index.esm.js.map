{"version":3,"file":"index.esm.js","sources":["../src/html.ts","../src/index.ts"],"sourcesContent":["import { Token } from \"micromark/dist/shared-types\";\n\n////////////////////////////////////////////////////////////\n\ntype CiteItemInfo = {\n\titems: {\n\t\tkey?: string\n\t}[]\n}\n\ntype StackType = CiteItemInfo[];\n\nexport type CiteHtmlOptions = {};\n\n////////////////////////////////////////////////////////////\n\n/**\n * Converts a token stream produced by the syntax extension\n * directly to HTML, with no intermediate AST.  For example,\n *\n * These functions rely on some unknown global state, so\n * if the input token stream is invalid, this function will\n * likely produce mysterious, difficult-to-diagnose errors.\n */\nexport function citeHtml(this: any, opts: CiteHtmlOptions = {}) {\n\n\t// ---- inlineCite ---------------------------------- //\n\n\tfunction enterInlineCite(this:any): void {\n\t\tlet stack: StackType|undefined = this.getData('inlineCiteStack');\n\t\tif (!stack) this.setData('inlineCiteStack', (stack = []));\n\t\tstack.push({ items: [] });\n\t}\n\n\tfunction exitInlineCite(this:any, token: Token): void {\n\t\tconst inlineCite: CiteItemInfo = this.getData('inlineCiteStack').pop();\n\n\t\t// gather citation data\n\t\tconst classNames = \"citation\";\n\t\tconst citeItems = inlineCite?.items || [];\n\t\tconst citeKeys = citeItems.map(item => item.key).join(\" \");\n\t\tconst citeText = this.sliceSerialize(token);\n\n\t\t// html output\n\t\tthis.tag(`<span class=\"${classNames}\" data-cites=\"${citeKeys}\">`);\n\t\tthis.raw(citeText);\n\t\tthis.tag('</span>');\n\t}\n\n\t// ---- citeItemKey --------------------------------- //\n\n\tfunction exitCiteItemKey(this:any, token: Token): void {\n\t\tconst citeKey = this.sliceSerialize(token);\n\t\tconst stack: StackType = this.getData('inlineCiteStack');\n\n\t\tconst current = top(stack);\n\t\tcurrent.items.push({ key: citeKey });\n\t}\n\n\tfunction top<T>(stack: T[]): T {\n\t\treturn stack[stack.length - 1];\n\t}\n\n\t// -------------------------------------------------- //\n\n\treturn {\n\t\tenter : {\n\t\t\tinlineCite: enterInlineCite,\n\t\t},\n\t\texit : {\n\t\t\tinlineCite: exitInlineCite,\n\t\t\tciteItemKey: exitCiteItemKey,\n\t\t}\n\t};\n}","// micromark\nimport { State, Effects, Resolve, Tokenizer, Event, Token } from \"micromark/dist/shared-types\";\nimport * as MM from \"micromark/dist/shared-types\";\nimport { CodeAsKey } from \"micromark/lib/shared-types\";\n\n// html converts token stream directly to html\nexport { citeHtml } from \"./html\"; \n\n////////////////////////////////////////////////////////////\n\n/**\n * As of (2021/05/05), the typings exported by `remark` do not\n * accurately reflect their usage, so we patch them here.\n *\n * When exporting functions, we need to be careful to cast back to\n * the built-in types, to be compatible with the current typings for remark.\n */\n\ntype SyntaxExtensionHook = { [key:number] : Construct | Construct[], 'null'?: Construct | Construct[] }\n\ninterface SyntaxExtension {\n\tdocument       ?: SyntaxExtensionHook,\n\tcontentInitial ?: SyntaxExtensionHook,\n\tflowInitial    ?: SyntaxExtensionHook,\n\tflow           ?: SyntaxExtensionHook,\n\tstring         ?: SyntaxExtensionHook,\n\ttext           ?: SyntaxExtensionHook,\n}\n\ntype Tokenize = (this: Tokenizer, effects: Effects, ok: State, nok: State) => State;\n\ninterface Construct {\n\tname?: string\n\ttokenize: Tokenize\n\tpartial?: boolean\n\tresolve?: Resolve\n\tresolveTo?: Resolve\n\tresolveAll?: Resolve\n\tconcrete?: boolean\n\tinterruptible?: boolean\n\tlazy?: boolean\n\t// typically extensions will want to get precedence over existing markdown \n\t// constructs. after can be used to invert that\n\t// https://github.com/micromark/micromark/discussions/54#discussioncomment-693151\n\tadd?: \"after\"|\"before\";\n}\n\ninterface TypeSafeEffects<T extends string> {\n  /**\n   * Enter and exit define where tokens start and end\n   */\n  enter: (type: T) => Token\n\n  /**\n   * Enter and exit define where tokens start and end\n   */\n  exit: (type: T) => Token\n\n  /**\n   * Consume deals with a character, and moves to the next\n   */\n  consume: (code: number) => void\n\n  /**\n   * Attempt deals with several values, and tries to parse according to those values.\n   * If a value resulted in `ok`, it worked, the tokens that were made are used,\n   * and `returnState` is switched to.\n   * If the result is `nok`, the attempt failed,\n   * so we revert to the original state, and `bogusState` is used.\n   */\n  attempt: (\n    constructInfo:\n      | Construct\n      | Construct[]\n      | Record<CodeAsKey, Construct | Construct[]>,\n    returnState: State,\n    bogusState?: State\n  ) => (code: number|null) => void\n\n  /**\n   * Interrupt is used for stuff right after a line of content.\n   */\n  interrupt: (\n    constructInfo:\n      | Construct\n      | Construct[]\n      | Record<CodeAsKey, Construct | Construct[]>,\n    ok: MM.Okay,\n    nok?: MM.NotOkay\n  ) => (code: number|null) => void\n\n  check: (\n    constructInfo:\n      | Construct\n      | Construct[]\n      | Record<CodeAsKey, Construct | Construct[]>,\n    ok: MM.Okay,\n    nok?: MM.NotOkay\n  ) => (code: number|null) => void\n\n  /**\n   * Lazy is used for lines that were not properly preceded by the container.\n   */\n  lazy: (\n    constructInfo:\n      | Construct\n      | Construct[]\n      | Record<CodeAsKey, Construct | Construct[]>,\n    ok: MM.Okay,\n    nok?: MM.NotOkay\n  ) => void\n}\n\n////////////////////////////////////////////////////////////\n\nexport interface CiteSyntaxOptions {\n\t/**\n\t * Enable the alternative syntax, `@[wadler1989]`.  The\n\t * first citation item can have a suffix, but no prefix.\n\t * There are no restrictions on subsequent items.\n\t * @default `false`\n\t */\n\tenableAltSyntax: boolean;\n\t/**\n\t * Enable the pandoc-style syntax, like `[@wadler1989]`.\n\t * Each individual citation can have a prefix and suffix.\n\t * @default `true`\n\t */\n\tenablePandocSyntax: boolean;\n}\n\n/**\n * Adds support for [`pandoc`-style citations](https://pandoc.org/MANUAL.html#citations-in-note-styles)\n * to `micromark`.  Here are some examples of valid citations:\n *     \n *    ```txt\n *    [@wadler1990:comprehending-monads]          --> (Wadler 1990)\n *    [-@wadler1990]                              --> (1990)\n *    [@hughes1989, sec 3.4]                      --> (Hughes 1989, sec 3.4)\n *    [see @wadler1990; and @hughes1989, pp. 4]   --> (see Wadler 1990 and Hughes 1989, pp. 4)\n *    ```\n */\nexport const citeSyntax = (function (options?: Partial<CiteSyntaxOptions>): SyntaxExtension {\n\t// handle user configuration\n\tconst settings = Object.assign({\n\t\tenableAltSyntax:    false,\n\t\tenablePandocSyntax: true,\n\t}, options);\n\n\t// hooks\n\tconst text: { [c:number]: Construct } = { };\n\n\t// activate pandoc-style syntax\n\tif(settings.enablePandocSyntax) {\n\t\ttext[91] = { tokenize: citeTokenize(false) }\n\t}\n\n\t// activate alternative syntax\n\tif(settings.enableAltSyntax) {\n\t\ttext[64] = { tokenize: citeTokenize(true) }\n\t}\n\n\t// assemble extension\n\treturn { text };\n}) as (options: Partial<CiteSyntaxOptions>) => MM.SyntaxExtension;\n\n////////////////////////////////////////////////////////////\n\nconst lookaheadConstruct = {\n\tpartial: true, \n\t/** If the next two characters are `-@`, run `ok`, else `nok`. */\n\ttokenize(effects: Effects, ok: State, nok: State): State {\n\t\treturn start\n\n\t\tfunction start(code: number) {\n\t\t\t// match hyphen `-`\n\t\t\tif(code !== 45) { return nok(code); }\n\t\t\teffects.consume(code);\n\t\t\treturn lookaheadAt;\n\t\t}\n\n\t\tfunction lookaheadAt(code: number) {\n\t\t\t// match at symbol `@`\n\t\t\tif(code !== 64) { return nok(code); }\n\t\t\teffects.consume(code);\n\t\t\treturn ok(code);\n\t\t}\n\t}\n};\n\n////////////////////////////////////////////////////////////\n\n// const enums are inlined at compile time\n// https://www.typescriptlang.org/docs/handbook/enums.html#const-enums\nconst enum CiteToken {\n\tinlineCite           = \"inlineCite\",\n\tinlineCiteMarker     = \"inlineCiteMarker\",\n\tinlineCiteMarker_alt = \"inlineCiteMarker_alt\",\n\tciteItem             = \"citeItem\",\n\tciteItemPrefix       = \"citeItemPrefix\",\n\tciteAuthorSuppress   = \"citeAuthorSuppress\",\n\tciteItemSymbol       = \"citeItemSymbol\",\n\tciteItemKey          = \"citeItemKey\",\n\tciteItemSuffix       = \"citeItemSuffix\",\n\tciteItemSep          = \"citeItemSep\",\n}\n\n/**\n * Entry-point for the citation tokenizer.\n * @param altSyntax If `true`, look ONLY for alt syntax.  If `false`, look ONLY for pandoc syntax. \n */\nconst citeTokenize: (altSyntax: boolean) => Tokenize = (altSyntax) => function(this: Tokenizer, effects: Effects|TypeSafeEffects<CiteToken>, ok: State, nok: State): State {\n\t// variables to keep track of parser state -- ideally the parsers below\n\t// would all be pure/deterministic, but that quickly got out of hand\n\tlet parseState = {\n\t\t/** helps detect empty citation keys */\n\t\tnonEmptyKey: false,\n\t\t/** note that this variable is only updated when we are looking\n\t\t  * for a prefix->key transition, when need to know whether the\n\t      * most recently consumed character was a space.            */\n\t\tlastWasSpace: false,\n\t\t/** are we currently in the prefix? */\n\t\tinPrefix: false,\n\t}\n\n\t// typos in strings manually passed to enter() / exit() have been\n\t// a source of bugs, so let TypeScript error-check for us\n\teffects = effects as unknown as TypeSafeEffects<CiteToken>;\n\n\t// return appropriate tokenizer for syntax type\n\treturn altSyntax ? start_alt : start_pandoc;\n\n\t// -- pandoc syntax --------------------------------- //\n\n\tfunction start_pandoc(code: number): State | void {\n\t\t// match left square bracket `[`\n\t\tif (code === 91) { \n\t\t\teffects.enter(CiteToken.inlineCite);\n\t\t\teffects.enter(CiteToken.inlineCiteMarker);\n\t\t\teffects.consume(code);\n\t\t\teffects.exit(CiteToken.inlineCiteMarker);\n\t\t\t\n\t\t\t// start looking for a citeItem\n\t\t\treturn consumeCiteItem;\n\t\t}\n\t\t// invalid starting character\n\t\telse { return nok(code); }\n\t}\n\n\t// -- alternative syntax ---------------------------- //\n\n\tfunction start_alt(code: number): State | void {\n\t\t// match at symbol `@`\n\t\tif (code === 64) {\n\t\t\teffects.enter(CiteToken.inlineCite);\n\t\t\teffects.enter(CiteToken.inlineCiteMarker_alt);\n\t\t\teffects.consume(code);\n\t\t\t\n\t\t\t// start looking for a citeItem\n\t\t\treturn alt_consumeLeftBracket;\n\t\t}\n\t\t// invalid starting character\n\t\telse { return nok(code); }\n\t}\n\n\t/*\n\t * (Alternative Syntax) See `enableAltSyntax` option.\n\t */\n\tfunction alt_consumeLeftBracket(code: number): State | void {\n\t\t// match left square bracket `[`\n\t\tif (code === 91) { \n\t\t\t// consume bracket\n\t\t\teffects.consume(code);\n\t\t\teffects.exit(CiteToken.inlineCiteMarker_alt);\n\n\t\t\t// skip prefix, start looking for cite key\n\t\t\teffects.enter(CiteToken.citeItem);\n\t\t\treturn alt_consumeInitialHyphen;\n\t\t\t//return consumeCiteItemKey;\n\t\t}\n\n\t\t// if we see a different character, this is not a citation\n\t\treturn nok(code);\n\t}\n\n\t/**\n\t * (alt syntax) look for a hyphen in the first citation item, as in\n\t *     `@[-suppressed]`\n\t */\n\tfunction alt_consumeInitialHyphen(code: number): State | void {\n\t\t// match hyphen `-`, indicating author suppression\n\t\tif(code === 45) {\n\t\t\teffects.enter(CiteToken.citeAuthorSuppress);\n\t\t\teffects.consume(code);\n\t\t\teffects.exit(CiteToken.citeAuthorSuppress);\n\t\t\t// look for citation key \n\t\t\teffects.enter(CiteToken.citeItemKey);\n\t\t\treturn consumeCiteItemKey;\n\t\t}\n\n\t\t// if no hyphen found, the first item is not suppressed\n\t\teffects.enter(CiteToken.citeItemKey);\n\t\treturn consumeCiteItemKey(code);\n\t}\n\n\t// -- shared tokenizers --------------------------------\n\n\t/**\n\t * @precondition token `citeItem` has already been emitted\n\t */\n\tfunction consumeCiteItem(code: number): State | void {\n\t\t// we haven't found any content yet\n\t\tparseState.nonEmptyKey = false;\n\t\teffects.enter(CiteToken.citeItem);\n\n\t\t// match hyphen `-`, indicating uathor suppression\n\t\tif (code === 45) { return lookaheadAuthorSuppress(code); }\n\t\t// match at symbol `@`, beginning the citation key\n\t\tif (code === 64) { return consumeAtSymbol(code);}\n\n\t\t// otherwise, we have a non-empty prefix\n\t\tparseState.lastWasSpace = false;\n\t\tparseState.inPrefix = true;\n\t\teffects.enter(CiteToken.citeItemPrefix);\n\t\treturn consumeCiteItemPrefix(code);\n\t}\n\n\t/**\n\t * @precondition `parseState.inPrefix = true`\n\t * @precondition token `citeItemPrefix` has already been emitted\n\t */\n\tfunction consumeCiteItemPrefix(this: any, code: number): State | void {\n\t\t// match hyphen '-', possibly indicating author suppression\n\t\tif (code === 45) { return lookaheadAuthorSuppress(code); }\n\t\t// match at symbol `@`, indicating end of prefix\n\t\tif (code === 64) { return consumeAtSymbol(code); };\n\t\t// if the closing bracket or eof occurs before we've found an \n\t\t// at symbol, then this is not actually a citation token, so we stop\n\t\tif (code === 93 || code === null) { return nok(code); }\n\n\t\t// otherwise, consume the next character of the prefix\n\t\tparseState.lastWasSpace = (code === 32);\n\t\teffects.consume(code);\n\t\treturn consumeCiteItemPrefix;\n\t}\n\n\t/**\n\t * When encountering a hyphen, we must look ahead at the next character\n\t * to determine whether the hyphen indicates author suppression or is\n\t * simply part of the citation prefix.\n\t */\n\tfunction lookaheadAuthorSuppress(this: any, code: number): State | void {\n\t\t// match hyphen `-`\n\t\tif(code !== 45) { return nok(code); }\n\t\t// lookahead\n\t\treturn effects.check(\n\t\t\t// check if the next two characters are `-@`\n\t\t\tlookaheadConstruct as any,\n\t\t\t// if they are, tokenize as citeAuthorSuppress\n\t\t\tconsumeAuthorSuppress,\n\t\t\t// otherwise, we're still in the prefix\n\t\t\tconsumeSingleCharInPrefix,\n\t\t)(code);\n\t}\n\n\t/**\n\t * Consumes a single character in prefix mode.\n\t * @effect starts prefix mode if we weren't already in it\n\t */\n\tfunction consumeSingleCharInPrefix(this: any, code: number): State | void {\n\t\t// make sure we are in prefix mode\n\t\tif(!parseState.inPrefix) {\n\t\t\teffects.enter(CiteToken.citeItemPrefix);\n\t\t\tparseState.inPrefix = true;\n\t\t}\n\n\t\teffects.consume(code);\n\t\treturn consumeCiteItemPrefix;\n\t}\n\n\t/**\n\t * @precondition We already KNOW the next TWO characters are `-@`.\n\t *     (called by `lookaheadAuthorSuppress`)\n\t */\n\tfunction consumeAuthorSuppress(this: any, code: number): State | void {\n\t\t// match hyphen `-`\n\t\tif(code !== 45) { return nok(code); }\n\n\t\t// end prefix, if we previously started it\n\t\tif(parseState.inPrefix) {\n\t\t\teffects.exit(CiteToken.citeItemPrefix);\n\t\t\tparseState.inPrefix = false;\n\t\t}\n\n\t\t// consume hyphen\n\t\teffects.enter(CiteToken.citeAuthorSuppress);\n\t\teffects.consume(code);\n\t\teffects.exit(CiteToken.citeAuthorSuppress);\n\n\t\t// consume at symbol\n\t\treturn consumeAtSymbol;\n\t}\n\t\n\tfunction consumeAtSymbol(this: any, code: number): State | void {\n\t\t// match at symbol `@`\n\t\tif(code !== 64) { return nok(code); }\n\n\t\tif(parseState.inPrefix) {\n\t\t\t// the prefix end with a space character\n\t\t\tif(!parseState.lastWasSpace) { return nok(code); }\n\t\t\t// indicate end of prefix, start of data\n\t\t\teffects.exit(CiteToken.citeItemPrefix);\n\t\t\tparseState.inPrefix = false;\n\t\t}\n\n\t\t// consume at symbol, which is not considered part of the key\n\t\teffects.enter(CiteToken.citeItemSymbol);\n\t\teffects.consume(code);\n\t\teffects.exit(CiteToken.citeItemSymbol);\n\t\t// next, get the text of the key\n\t\teffects.enter(CiteToken.citeItemKey);\n\t\treturn consumeCiteItemKey;\n\t}\n\n\tfunction consumeCiteItemKey(code: number): State | void {\n\t\t// pandoc is specific about which characters are allowed\n\t\t// in a citation key, but since javascript has no multi-\n\t\t// lingual way to test for alphanumeric characters, we\n\t\t// allow any characters EXCEPT whitespace and `];`\n\n\t\t// match right square bracket `]` or item sep `;` to handle empty keys\n\t\tif (code === 93 || code == 59) {\n\t\t\t// handle empty key like `[prefix @]`\n\t\t\tif(!parseState.nonEmptyKey) { return nok(code); }\n\n\t\t\teffects.exit(CiteToken.citeItemKey);\n\n\t\t\t// this item had no suffix\n\t\t\teffects.exit(CiteToken.citeItem);\n\n\t\t\t// match right square bracket `]`, indicating end of inlineCite node\n\t\t\tif (code === 93) {\n\t\t\t\t// continue without consuming the closing bracket `]`\n\t\t\t\treturn consumeCiteEnd(code);\n\t\t\t}\n\n\t\t\t// match semicolon `;`, indicating, the end of the current citeItem\n\t\t\tif (code === 59){\n\t\t\t\t// consume item separator `;`\n\t\t\t\teffects.enter(CiteToken.citeItemSep);\n\t\t\t\teffects.consume(code);\n\t\t\t\teffects.exit(CiteToken.citeItemSep);\n\n\t\t\t\t// continue to the next item\n\t\t\t\treturn consumeCiteItem;\n\t\t\t}\n\t\t}\n\n\t\t// match space or comma, indicating start of suffix\n\t\tif (code === 32 || code === 44) {\n\t\t\t// handle empty key like `[prefix @, suffix]`\n\t\t\tif(!parseState.nonEmptyKey) { return nok(code); }\n\n\t\t\teffects.exit(CiteToken.citeItemKey);\n\t\t\t// continue to suffix, without consuming character\n\t\t\t// (this character belongs to the suffix, so suffix is non-empty)\n\t\t\teffects.enter(CiteToken.citeItemSuffix);\n\t\t\treturn consumeCiteItemSuffix(code);\n\t\t}\n\n\t\t// CR, LF, CRLF, HT, VS (whitespace, EOLs, EOF)\n\t\tif (code === null || code < 0) {\n\t\t\treturn nok(code);\n\t\t}\n\n\t\tparseState.nonEmptyKey = true;\n\t\t\n\t\t// otherwise, continue consuming characters\n\t\teffects.consume(code);\n\t\treturn consumeCiteItemKey;\n\t}\n\n\tfunction consumeCiteItemSuffix(code: number): State | void {\n\t\t// fail on eof\n\t\tif (code === null) { return nok(code); }\n\n\t\t// match right square bracket `]`, indicating end of inlineCite node\n\t\tif (code === 93) {\n\t\t\t// we're done!  close this item and finish up\n\t\t\teffects.exit(CiteToken.citeItemSuffix);\n\t\t\teffects.exit(CiteToken.citeItem);\n\t\t\t// continue without consuming the closing bracket `]`\n\t\t\treturn consumeCiteEnd(code);\n\t\t}\n\n\t\t// match semicolon `;`, indicating, the end of the current citeItem\n\t\tif (code === 59){\n\t\t\teffects.exit(CiteToken.citeItemSuffix);\n\t\t\teffects.exit(CiteToken.citeItem);\n\n\t\t\t// consume item separator `;`\n\t\t\teffects.enter(CiteToken.citeItemSep);\n\t\t\teffects.consume(code);\n\t\t\teffects.exit(CiteToken.citeItemSep);\n\n\t\t\t// continue to the next item\n\t\t\treturn consumeCiteItem;\n\t\t}\n\n\t\t// otherwise, continue consuming characters\n\t\teffects.consume(code);\n\t\treturn consumeCiteItemSuffix;\n\t}\n\n\tfunction consumeCiteEnd(code: number): State | void {\n\t\t// match right square bracket `]`\n\t\tif (code !== 93) { return nok(code); }\n\t\t\n\t\t// consume closing bracket `]`\n\t\teffects.enter(CiteToken.inlineCiteMarker);\n\t\teffects.consume(code);\n\t\teffects.exit(CiteToken.inlineCiteMarker);\n\t\teffects.exit(CiteToken.inlineCite);\n\n\t\t// we're all done!\n\t\treturn ok;\n\t}\n}"],"names":[],"mappings":"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"}