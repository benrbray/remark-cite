{"version":3,"file":"index.cjs.js","sources":["../src/html.ts","../src/index.ts"],"sourcesContent":["import { Token } from \"micromark/dist/shared-types\";\n\n////////////////////////////////////////////////////////////\n\ntype CiteItemInfo = {\n\titems: {\n\t\tkey?: string\n\t}[]\n}\n\ntype StackType = CiteItemInfo[];\n\nexport type CiteHtmlOptions = {};\n\n////////////////////////////////////////////////////////////\n\n/**\n * Converts a token stream produced by the syntax extension\n * directly to HTML, with no intermediate AST.  For example,\n *\n * These functions rely on some unknown global state, so\n * if the input token stream is invalid, this function will\n * likely produce mysterious, difficult-to-diagnose errors.\n */\nexport function html(this: any, opts: CiteHtmlOptions = {}) {\n\n\t// ---- inlineCite ---------------------------------- //\n\n\tfunction enterInlineCite(this:any): void {\n\t\tlet stack: StackType|undefined = this.getData('inlineCiteStack');\n\t\tif (!stack) this.setData('inlineCiteStack', (stack = []));\n\t\tstack.push({ items: [] });\n\t}\n\n\tfunction exitInlineCite(this:any, token: Token): void {\n\t\tconst inlineCite: CiteItemInfo = this.getData('inlineCiteStack').pop();\n\n\t\t// gather citation data\n\t\tconst classNames = \"citation\";\n\t\tconst citeItems = inlineCite?.items || [];\n\t\tconst citeKeys = citeItems.map(item => item.key).join(\" \");\n\t\tconst citeText = this.sliceSerialize(token);\n\n\t\t// html output\n\t\tthis.tag(`<span class=\"${classNames}\" data-cites=\"${citeKeys}\">`);\n\t\tthis.raw(citeText);\n\t\tthis.tag('</span>');\n\t}\n\n\t// ---- citeItemKey --------------------------------- //\n\n\tfunction exitCiteItemKey(this:any, token: Token): void {\n\t\tconst citeKey = this.sliceSerialize(token);\n\t\tconst stack: StackType = this.getData('inlineCiteStack');\n\n\t\tconst current = top(stack);\n\t\tcurrent.items.push({ key: citeKey });\n\t}\n\n\tfunction top<T>(stack: T[]): T {\n\t\treturn stack[stack.length - 1];\n\t}\n\n\t// -------------------------------------------------- //\n\n\treturn {\n\t\tenter : {\n\t\t\tinlineCite: enterInlineCite,\n\t\t},\n\t\texit : {\n\t\t\tinlineCite: exitInlineCite,\n\t\t\tciteItemKey: exitCiteItemKey,\n\t\t}\n\t};\n}","// micromark\nimport { State, Effects, Resolve, Tokenizer, Event, Token } from \"micromark/dist/shared-types\";\nimport * as MM from \"micromark/dist/shared-types\";\n\n// html converts token stream directly to html\nexport { html } from \"./html\"; \n\n////////////////////////////////////////////////////////////\n\n/**\n * As of (2021/05/05), the typings exported by `remark` do not\n * accurately reflect their usage, so we patch them here.\n *\n * When exporting functions, we need to be careful to cast back to\n * the built-in types, to be compatible with the current typings for remark.\n */\n\ntype SyntaxExtensionHook = { [key:number] : Construct | Construct[], 'null'?: Construct | Construct[] }\n\ninterface SyntaxExtension {\n\tdocument       ?: SyntaxExtensionHook,\n\tcontentInitial ?: SyntaxExtensionHook,\n\tflowInitial    ?: SyntaxExtensionHook,\n\tflow           ?: SyntaxExtensionHook,\n\tstring         ?: SyntaxExtensionHook,\n\ttext           ?: SyntaxExtensionHook,\n}\n\ntype Tokenize = (this: Tokenizer, effects: Effects, ok: State, nok: State) => State;\n\ninterface Construct {\n\tname?: string\n\ttokenize: Tokenize\n\tpartial?: boolean\n\tresolve?: Resolve\n\tresolveTo?: Resolve\n\tresolveAll?: Resolve\n\tconcrete?: boolean\n\tinterruptible?: boolean\n\tlazy?: boolean\n\t// typically extensions will want to get precedence over existing markdown \n\t// constructs. after can be used to invert that\n\t// https://github.com/micromark/micromark/discussions/54#discussioncomment-693151\n\tadd?: \"after\"|\"before\";\n}\n\n////////////////////////////////////////////////////////////\n\nexport interface CiteOptions {\n\t\n}\n\n/**\n * Adds support for [`pandoc`-style citations](https://pandoc.org/MANUAL.html#citations-in-note-styles)\n * to `micromark`.  Here are some examples of valid citations:\n *     \n *    ```txt\n *    [@wadler1990:comprehending-monads]          --> (Wadler 1990)\n *    [-@wadler1990]                              --> (1990)\n *    [@hughes1989, sec 3.4]                      --> (Hughes 1989, sec 3.4)\n *    [see @wadler1990; and @hughes1989, pp. 4]   --> (see Wadler 1990 and Hughes 1989, pp. 4)\n *    ```\n *\n * This extension introduces a new `unist` node type.\n *     \n *     interface CitationInfo {\n *         prefix?: string;\n *         key: string;\n *         suffix?: string;\n *     }\n *     \n *     interface Citation <: Literal {\n *         type: \"citation\"\n *         data: {\n *             citeItems: CitationInfo[]\n *         }\n *     }\n */\nexport const citeExtension = (function (options: CiteOptions): SyntaxExtension {\n\t// handle user configuration\n\tlet settings = options || {};\n\n\t// matches the opening bracket of an inline citation\n\tlet citeStart: Construct = {\n\t\ttokenize: citeTokenize\n\t}\n\n\t// assemble extension\n\treturn {\n\t\ttext: {\n\t\t\t91: citeStart // left square bracket `[`\n\t\t}\n\t}\n}) as (options: CiteOptions) => MM.SyntaxExtension;\n\n////////////////////////////////////////////////////////////\n\n/**\n * Entry-point for the citation tokenizer.\n * \n */\nconst citeTokenize: Tokenize = function(this: Tokenizer, effects: Effects, ok: State, nok: State): State {\n\t// variables to keep track of parser state\n\n\tlet parseState = {\n\t\t/** helps detect empty citation keys */\n\t\tnonEmptyKey: false,\n\t\t/** note that this variable is only updated when we are looking\n\t\t  * for a prefix->key transition, when need to know whether the\n\t      * most recently consumed character was a space.               */\n\t\tlastWasSpace: false\n\t}\n\n\treturn start;\n\n\tfunction start(code: number): State | void {\n\t\t// match left square bracket `[`\n\t\t// (technically not necessary, if we trust the hook that brought us here)\n\t\tif (code !== 91) { return nok(code); }\n\n\t\teffects.enter(\"inlineCite\");\n\t\teffects.enter(\"inlineCiteMarker\");\n\t\teffects.consume(code);\n\t\teffects.exit(\"inlineCiteMarker\");\n\t\t\n\t\t// start looking for a citeItem\n\t\treturn consumeCiteItem;\n\t}\n\n\tfunction consumeCiteItem(code: number): State | void {\n\t\t// we haven't found any content yet\n\t\tparseState.nonEmptyKey = false;\n\n\t\teffects.enter(\"citeItem\");\n\n\t\t// match at symbol `@`, beginning the citation key\n\t\tif (code === 64) { \n\t\t\t// consume at symbol, which is not considered part of the key\n\t\t\teffects.enter(\"citeItemSymbol\");\n\t\t\teffects.consume(code);\n\t\t\teffects.exit(\"citeItemSymbol\");\n\t\t\t// next, get the text of the key\n\t\t\teffects.enter(\"citeItemKey\");\n\t\t\treturn consumeCiteItemKey;\n\t\t}\n\n\t\t// otherwise, we have a non-empty prefix\n\t\tparseState.lastWasSpace = false;\n\t\teffects.enter(\"citeItemPrefix\");\n\t\treturn consumeCiteItemPrefix(code);\n\t}\n\n\tfunction consumeCiteItemPrefix(this: any, code: number): State | void {\n\t\t// match at symbol `@`, indicating end of prefix\n\t\tif (code === 64) { \n\t\t\t// the prefix end with a space character\n\t\t\tif(!parseState.lastWasSpace) { return nok(code); }\n\n\t\t\t// indicate end of prefix, start of data\n\t\t\teffects.exit(\"citeItemPrefix\");\n\t\t\t// consume at symbol, which is not considered part of the key\n\t\t\teffects.enter(\"citeItemSymbol\");\n\t\t\teffects.consume(code);\n\t\t\teffects.exit(\"citeItemSymbol\");\n\t\t\t// next, get the text of the key\n\t\t\teffects.enter(\"citeItemKey\");\n\t\t\treturn consumeCiteItemKey;\n\t\t};\n\n\t\t// if the closing bracket or eof occurs before we've found an \n\t\t// at symbol, then this is not actually a citation token, so we stop\n\t\tif (code === 93 || code === null) {\n\t\t\treturn nok(code);\n\t\t}\n\n\t\t// otherwise, consume the next character of the prefix\n\t\tparseState.lastWasSpace = (code === 32);\n\t\teffects.consume(code);\n\t\treturn consumeCiteItemPrefix;\n\t}\n\n\tfunction consumeCiteItemKey(code: number): State | void {\n\t\t// pandoc is specific about which characters are allowed\n\t\t// in a citation key, but since javascript has no multi-\n\t\t// lingual way to test for alphanumeric characters, we\n\t\t// allow any characters EXCEPT whitespace and `];`\n\n\t\t// match right square bracket `]` or item sep `;` to handle empty keys\n\t\tif (code === 93 || code == 59) {\n\t\t\t// handle empty key like `[prefix @]`\n\t\t\tif(!parseState.nonEmptyKey) { return nok(code); }\n\n\t\t\teffects.exit(\"citeItemKey\");\n\n\t\t\t// this item had no suffix\n\t\t\teffects.exit(\"citeItem\");\n\n\t\t\t// match right square bracket `]`, indicating end of inlineCite node\n\t\t\tif (code === 93) {\n\t\t\t\t// continue without consuming the closing bracket `]`\n\t\t\t\treturn consumeCiteEnd(code);\n\t\t\t}\n\n\t\t\t// match semicolon `;`, indicating, the end of the current citeItem\n\t\t\tif (code === 59){\n\t\t\t\t// consume item separator `;`\n\t\t\t\teffects.enter(\"citeItemSep\");\n\t\t\t\teffects.consume(code);\n\t\t\t\teffects.exit(\"citeItemSep\");\n\n\t\t\t\t// continue to the next item\n\t\t\t\treturn consumeCiteItem;\n\t\t\t}\n\t\t}\n\n\t\t// match space or comma, indicating start of suffix\n\t\tif (code === 32 || code === 44) {\n\t\t\t// handle empty key like `[prefix @, suffix]`\n\t\t\tif(!parseState.nonEmptyKey) { return nok(code); }\n\n\t\t\teffects.exit(\"citeItemKey\");\n\t\t\t// continue to suffix, without consuming character\n\t\t\t// (this character belongs to the suffix, so suffix is non-empty)\n\t\t\teffects.enter(\"citeItemSuffix\");\n\t\t\treturn consumeCiteItemSuffix(code);\n\t\t}\n\n\t\t// CR, LF, CRLF, HT, VS (whitespace, EOLs, EOF)\n\t\tif (code === null || code < 0) {\n\t\t\treturn nok(code);\n\t\t}\n\n\t\tparseState.nonEmptyKey = true;\n\t\t\n\t\t// otherwise, continue consuming characters\n\t\teffects.consume(code);\n\t\treturn consumeCiteItemKey;\n\t}\n\n\tfunction consumeCiteItemSuffix(code: number): State | void {\n\t\t// match right square bracket `]`, indicating end of inlineCite node\n\t\tif (code === 93) {\n\t\t\t// we're done!  close this item and finish up\n\t\t\teffects.exit(\"citeItemSuffix\");\n\t\t\teffects.exit(\"citeItem\");\n\t\t\t// continue without consuming the closing bracket `]`\n\t\t\treturn consumeCiteEnd(code);\n\t\t}\n\n\t\t// match semicolon `;`, indicating, the end of the current citeItem\n\t\tif (code === 59){\n\t\t\teffects.exit(\"citeItemSuffix\");\n\t\t\teffects.exit(\"citeItem\");\n\n\t\t\t// consume item separator `;`\n\t\t\teffects.enter(\"citeItemSep\");\n\t\t\teffects.consume(code);\n\t\t\teffects.exit(\"citeItemSep\");\n\n\t\t\t// continue to the next item\n\t\t\treturn consumeCiteItem;\n\t\t}\n\n\t\t// otherwise, continue consuming characters\n\t\teffects.consume(code);\n\t\treturn consumeCiteItemSuffix;\n\t}\n\n\tfunction consumeCiteEnd(code: number): State | void {\n\t\t// match right square bracket `]`\n\t\tif (code !== 93) { return nok(code); }\n\t\t\n\t\t// consume closing bracket `]`\n\t\teffects.enter(\"inlineCiteMarker\");\n\t\teffects.consume(code);\n\t\teffects.exit(\"inlineCiteMarker\");\n\t\teffects.exit(\"inlineCite\");\n\n\t\t// we're all done!\n\t\treturn ok;\n\t}\n}"],"names":[],"mappings":"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"}